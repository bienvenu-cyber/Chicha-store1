'use strict'

const Client = import('./lib/dispatcher/client')
const Dispatcher = import('./lib/dispatcher/dispatcher')
const Pool = import('./lib/dispatcher/pool')
const BalancedPool = import('./lib/dispatcher/balanced-pool')
const Agent = import('./lib/dispatcher/agent')
const ProxyAgent = import('./lib/dispatcher/proxy-agent')
const EnvHttpProxyAgent = import('./lib/dispatcher/env-http-proxy-agent')
const RetryAgent = import('./lib/dispatcher/retry-agent')
const errors = import('./lib/core/errors')
const util = import('./lib/core/util')
const { InvalidArgumentError } = errors
const api = import('./lib/api')
const buildConnector = import('./lib/core/connect')
const MockClient = import('./lib/mock/mock-client')
const MockAgent = import('./lib/mock/mock-agent')
const MockPool = import('./lib/mock/mock-pool')
const mockErrors = import('./lib/mock/mock-errors')
const RetryHandler = import('./lib/handler/retry-handler')
const { getGlobalDispatcher, setGlobalDispatcher } = import('./lib/global')
const DecoratorHandler = import('./lib/handler/decorator-handler')
const RedirectHandler = import('./lib/handler/redirect-handler')
const createRedirectInterceptor = import('./lib/interceptor/redirect-interceptor')

Object.assign(Dispatcher.prototype, api)

export default.Dispatcher = Dispatcher
export default.Client = Client
export default.Pool = Pool
export default.BalancedPool = BalancedPool
export default.Agent = Agent
export default.ProxyAgent = ProxyAgent
export default.EnvHttpProxyAgent = EnvHttpProxyAgent
export default.RetryAgent = RetryAgent
export default.RetryHandler = RetryHandler

export default.DecoratorHandler = DecoratorHandler
export default.RedirectHandler = RedirectHandler
export default.createRedirectInterceptor = createRedirectInterceptor
export default.interceptors = {
  redirect: import('./lib/interceptor/redirect'),
  retry: import('./lib/interceptor/retry'),
  dump: import('./lib/interceptor/dump')
}

export default.buildConnector = buildConnector
export default.errors = errors
export default.util = {
  parseHeaders: util.parseHeaders,
  headerNameToString: util.headerNameToString
}

function makeDispatcher (fn) {
  return (url, opts, handler) => {
    if (typeof opts === 'function') {
      handler = opts
      opts = null
    }

    if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {
      throw new InvalidArgumentError('invalid url')
    }

    if (opts != null && typeof opts !== 'object') {
      throw new InvalidArgumentError('invalid opts')
    }

    if (opts && opts.path != null) {
      if (typeof opts.path !== 'string') {
        throw new InvalidArgumentError('invalid opts.path')
      }

      let path = opts.path
      if (!opts.path.startsWith('/')) {
        path = `/${path}`
      }

      url = new URL(util.parseOrigin(url).origin + path)
    } else {
      if (!opts) {
        opts = typeof url === 'object' ? url : {}
      }

      url = util.parseURL(url)
    }

    const { agent, dispatcher = getGlobalDispatcher() } = opts

    if (agent) {
      throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?')
    }

    return fn.call(dispatcher, {
      ...opts,
      origin: url.origin,
      path: url.search ? `${url.pathname}${url.search}` : url.pathname,
      method: opts.method || (opts.body ? 'PUT' : 'GET')
    }, handler)
  }
}

export default.setGlobalDispatcher = setGlobalDispatcher
export default.getGlobalDispatcher = getGlobalDispatcher

const fetchImpl = import('./lib/web/fetch').fetch
export default.fetch = async function fetch (init, options = undefined) {
  try {
    return await fetchImpl(init, options)
  } catch (err) {
    if (err && typeof err === 'object') {
      Error.captureStackTrace(err)
    }

    throw err
  }
}
export default.Headers = import('./lib/web/fetch/headers').Headers
export default.Response = import('./lib/web/fetch/response').Response
export default.Request = import('./lib/web/fetch/request').Request
export default.FormData = import('./lib/web/fetch/formdata').FormData
export default.File = globalThis.File ?? import('node:buffer').File
export default.FileReader = import('./lib/web/fileapi/filereader').FileReader

const { setGlobalOrigin, getGlobalOrigin } = import('./lib/web/fetch/global')

export default.setGlobalOrigin = setGlobalOrigin
export default.getGlobalOrigin = getGlobalOrigin

const { CacheStorage } = import('./lib/web/cache/cachestorage')
const { kConstruct } = import('./lib/web/cache/symbols')

// Cache & CacheStorage are tightly coupled with fetch. Even if it may run
// in an older version of Node, it doesn't have any use without fetch.
export default.caches = new CacheStorage(kConstruct)

const { deleteCookie, getCookies, getSetCookies, setCookie } = import('./lib/web/cookies')

export default.deleteCookie = deleteCookie
export default.getCookies = getCookies
export default.getSetCookies = getSetCookies
export default.setCookie = setCookie

const { parseMIMEType, serializeAMimeType } = import('./lib/web/fetch/data-url')

export default.parseMIMEType = parseMIMEType
export default.serializeAMimeType = serializeAMimeType

const { CloseEvent, ErrorEvent, MessageEvent } = import('./lib/web/websocket/events')
export default.WebSocket = import('./lib/web/websocket/websocket').WebSocket
export default.CloseEvent = CloseEvent
export default.ErrorEvent = ErrorEvent
export default.MessageEvent = MessageEvent

export default.request = makeDispatcher(api.request)
export default.stream = makeDispatcher(api.stream)
export default.pipeline = makeDispatcher(api.pipeline)
export default.connect = makeDispatcher(api.connect)
export default.upgrade = makeDispatcher(api.upgrade)

export default.MockClient = MockClient
export default.MockPool = MockPool
export default.MockAgent = MockAgent
export default.mockErrors = mockErrors

const { EventSource } = import('./lib/web/eventsource/eventsource')

export default.EventSource = EventSource
